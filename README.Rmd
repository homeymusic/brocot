---
output: github_document
title: "brocot"
---

```{r, echo=F}
devtools::load_all(".")
```

![](man/figures/brocot_logo.png){ width=120px align=right }

`brocot` is an R package for exploring physics with coprime fractions.

# Quantization using rational numbers and Heisenberg uncertainty

There has never been an experimental result in physics given with irrational numbers,
which are infinite idealizations. Furthermore, experimental quantum physics has given 
results that are integers and rational fractions. Our approach in this model
is to assert that the ontological actual values of physics are confined to rational 
numbers and that real values are epistemological approximations limited by the 
Heisenberg uncertainty principle.

Below, we will demonstrate that particle observations when mapped from real numbers 
to rational numbers using the Stern-Brocot tree bounded by Heisenberg uncertainty yields distributions that are experimentally indistinguishable from the distributions given
by the traditional wavefunctions. This model does not introduce probability distributions
or hidden variables. Instead, quantum phenomena emerge from the inherently discrete yet dense
nature of the rational numbers.

## Heisenberg Uncertainty

$\Delta \tilde{x} \Delta \tilde{p} \ge \frac{\hbar}{2}$

### Boundary conditions

Boundary conditions at the quantum scale are modeled with split uncertainties. For example,
in the two slit experiment, a particle's epistemological approximation is given as $\tilde{x}$. The distance between the particle and the left side of the slit would be given as $\Delta \tilde{x}_< =  |\tilde{x}_{left} - \tilde{x}|$ and the distance between the particle and the right side of the slit would be given as $\Delta \tilde{x}_> =  |\tilde{x}_{right} - \tilde{x}|$.

$\Delta \tilde{x} = \Delta \tilde{x}_< + \Delta \tilde{x}_> \quad \Delta \tilde{p} = \Delta \tilde{p}_< + \Delta \tilde{p}_>$

$\tilde{x} - \Delta \tilde{x}_< \lt \tilde{x} \lt \tilde{x} + \Delta \tilde{x}_> \quad \tilde{p} - \Delta \tilde{p}_< \lt \tilde{p} \lt \tilde{p} + \Delta \tilde{p}_>$

## Stern-Brocot Heisenberg Quantizer

The Stern-Brocot tree maps from real, epistemological approximates $\tilde{x}, \tilde{p}$ 
to rational, ontological actuals $x, p$.

$x = \operatorname{Q}(\Delta \tilde{x}_<, \tilde{x}, \Delta \tilde{x}_>) \quad p = \operatorname{Q}(\Delta \tilde{p}_<, \tilde{p}, \Delta \tilde{p}_>)$

$x,p \in \mathbb{Q}_\perp \quad \tilde{x}, \tilde{p} \in \mathbb{R}$

$\mathbb{Q}_\perp = \left\{ \frac{a}{b} \in \mathbb{Q} \mid a \perp b \iff \gcd(a, b) = 1, a \in \mathbb{Z}, b \in \mathbb{N} \right\}$

$x = \operatorname{Q}(\Delta \tilde{x}_<, \tilde{x}, \Delta \tilde{x}_>)$

$x = \arg\min_{x' \in \{x_<, x_>\}} |\tilde{x} - x'|$

$x_< = \operatorname{SB}(\Delta \tilde{x}_<, \tilde{x}, 0), \quad x_> = \operatorname{SB}(0, \tilde{x}, \Delta \tilde{x}_>)$

### Thomae's Function

The likelihood that a particle within the slit is at position $x$ is approximated 
by Thomae's function:

$f(x) = \begin{cases} \frac{1}{b}, & \text{if } x = \frac{a}{b}, a \perp b \\ 0, & \text{if } x \text{ is irrational} \end{cases}$


Computational simulations show the same wavelike results as physical one and two slit experiments.

## The relationship between position and momentum

$\Delta \tilde{x} \ge \frac{\hbar}{2 \Delta \tilde{p}} \quad \Delta \tilde{p} \ge \frac{\hbar}{2 \Delta \tilde{x}}$

$\Delta \tilde{p}_< = \frac{\hbar}{2 \Delta \tilde{x}_<} \quad \Delta \tilde{p}_> = \frac{\hbar}{2 \Delta \tilde{x}_>}$

$d\tilde{p} = \Delta \tilde{p}_> - \Delta \tilde{p}_<$

$\tilde{p} = \tilde{p_0} + d \tilde{p}$

$\Delta \tilde{x}_< = \frac{\hbar}{2 \Delta \tilde{p}_<} \quad \Delta \tilde{x}_> = \frac{\hbar}{2 \Delta \tilde{p}_>}$

$d\tilde{x} = \frac{\Delta \tilde{x}_< + \Delta \tilde{x}_>}{2}$

$\tilde{x} = \tilde{x_0} + d \tilde{x}$

```{r, echo=FALSE}
num_samples  = 501
num_bins     = 501
slit_width   = 17

dx           = slit_width/num_samples
min_x        = -slit_width / 2 + dx
max_x        =  slit_width / 2 - dx
x_real       = seq(from=min_x, to=max_x, by=dx)
sigma_x_lt   = x_real - min_x + dx
sigma_x_gt   = max_x - x_real + dx
x = coprimer::nearby_coprime(x_real, sigma_x_lt, sigma_x_gt)

sigma_p_lt   = 1 / sigma_x_lt
sigma_p_gt   = 1 / sigma_x_gt
p_real       = sigma_p_gt - sigma_p_lt
p = coprimer::nearby_coprime(p_real, sigma_p_lt, sigma_p_gt)
```

## Position vs Momentum

```{r, echo=FALSE}
plot_scatter(
  data = data.frame(x = x$approximation, p = p$approximation),
  x_col = "x",
  y_col = "p",
  title = "Position vs Momentum",
  x_label = "x",
  y_label = "p"
)

```

## Position

```{r, echo=FALSE}
# Generate plots for Position (x)
plot_histogram(x, num_bins, "approximation", "Histogram of Position", "Rational Number")
plot_segments(x, "approximation", "thomae", "Thomae's Function of Position", "Approximation", "Thomae")
plot_segments(x, "approximation", "euclids_orchard_height", "Euclid's Orchard of Position", "Approximation", "Redundancy")
plot_histogram(x, num_bins, "error", "Histogram of Position Errors", "Error")
plot_scatter(x, "approximation", "depth", "Stern-Brocot Depth vs. Position", "Approximation", "Depth")
```

## Momentum

```{r, echo=FALSE}
# Generate plots for Momentum (p)
plot_histogram(p, num_bins, "approximation", "Histogram of Momentum", "Rational Number")
plot_segments(p, "approximation", "thomae", "Thomae's Function of Momentum", "Approximation", "Thomae")
plot_segments(p, "approximation", "euclids_orchard_height", "Euclid's Orchard of Momentum", "Approximation", "Redundancy")
plot_histogram(p, num_bins, "error", "Histogram of Momentum Errors", "Error")
plot_scatter(p, "approximation", "depth", "Stern-Brocot Depth vs. Momentum", "Approximation", "Depth")
```

## From Position to Momentum to Position

```{r, echo=T}
num_samples  = 5
num_bins     = 5
slit_width   = 17

dx           = slit_width/num_samples
min_x        = -slit_width / 2 + dx
max_x        =  slit_width / 2 - dx
x_real       = seq(from=min_x, to=max_x, by=dx)
sigma_x_lt   = x_real - min_x + dx
sigma_x_gt   = max_x - x_real + dx
x = coprimer::nearby_coprime(x_real, sigma_x_lt, sigma_x_gt)
print(x)
```

```{r, echo=T}
sigma_p_lt   = 1 / sigma_x_lt
sigma_p_gt   = 1 / sigma_x_gt
p_real       = sigma_p_gt - sigma_p_lt
p = coprimer::nearby_coprime(p_real, sigma_p_lt, sigma_p_gt)
print(p)
```

```{r, echo=T}
sigma_x_conj_lt = 1 / sigma_p_lt
sigma_x_conj_gt = 1 / sigma_p_gt
x_conj_real     = (sigma_x_conj_lt - sigma_x_conj_gt) / 2
x_conj          = coprimer::nearby_coprime(x_conj_real, sigma_x_conj_lt, sigma_x_conj_gt)
print(x_conj)
```

```{r, echo=T}
print(x == x_conj)
```

